# We're not using Requires because it gets in the way on PSv2
#!Requires -Version 2 -Modules "Configuration"
###############################################################################
## Copyright (c) 2013 by Joel Bennett, all rights reserved.
## Free for use under MS-PL, MS-RL, GPL 2, or BSD license. Your choice. 
###############################################################################
## Installation.psm1 defines the core commands for installing packages:
## Get-ModuleInfo and Install-ModulePackage 
## It depends on the Configuration module and the Invoke-WebRequest cmdlet
Add-Type -Assembly WindowsBase

# FULL # BEGIN FULL: Don't include this in the installer script
if(!(Get-Command Invoke-WebRequest -ErrorAction SilentlyContinue)){
  Import-Module $PSScriptRoot\InvokeWeb
}
# NOTE: these types are needed elsewhere (Packaging Module)
#       the types aren't needed for the installer
#       but they are part of the "packaging light" module, so here they are.
# This is what nuget uses for .nuspec, we use it for .moduleinfo ;)
$Script:ManifestType            = "http://schemas.microsoft.com/packaging/2010/07/manifest"
# We need to make up a URL for the metadata psd1 relationship type
$Script:ModuleMetadataType      = "http://schemas.poshcode.org/package/module-metadata"
$Script:ModuleHelpInfoType      = "http://schemas.poshcode.org/package/help-info"
$Script:PackageThumbnailType    = "http://schemas.openxmlformats.org/package/2006/relationships/metadata/thumbnail"
# I'm not sure there's any benefit to extra types:
# CorePropertiesType is the .psmdcp
$Script:CorePropertiesType      = "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties"
$Script:ModuleRootType          = "http://schemas.poshcode.org/package/module-root"
$Script:ModuleContentType       = "http://schemas.poshcode.org/package/module-file"
$Script:ModuleReleaseType       = "http://schemas.poshcode.org/package/module-release"
$Script:ModuleLicenseType       = "http://schemas.poshcode.org/package/module-license"
# FULL # END FULL

# Our Extensions
$Script:ModuleInfoFile          = "package.psd1"
$Script:ModuleInfoExtension     = ".psd1"
$Script:ModuleManifestExtension = ".psd1"
$Script:ModulePackageExtension  = ".psmx"

function Install-ModulePackage {
  #.Synopsis
  #   Install a module package to the module 
  [CmdletBinding(SupportsShouldProcess=$true, ConfirmImpact="Medium", DefaultParameterSetName="UserPath")]
  param(
    # The package file to be installed
    [Parameter(ValueFromPipelineByPropertyName=$true, Mandatory=$true, Position=0)]
    [Alias("PSPath","PackagePath","ModuleInfoUri")]
    $Package,

    # The PSModulePath to install to
    [Parameter(ParameterSetName="InstallPath", Mandatory=$true, Position=1)]
    [Alias("PSModulePath")]
    $InstallPath,

    # If set, the module is installed to the Common module path (as specified in Packaging.ini)
    [Parameter(ParameterSetName="CommonPath", Mandatory=$true)]
    [Switch]$Common,

    # If set, the module is installed to the User module path (as specified in Packaging.ini)
    [Parameter(ParameterSetName="UserPath")]
    [Switch]$User,

    # If set, overwrite existing modules without prompting
    [Switch]$Force,

    # If set, the module is imported immediately after install
    [Switch]$Import,

    # If set, output information about the files as well as the module 
    [Switch]$Passthru,

    #  Specifies the client certificate that is used for a secure web request. Enter a variable that contains a certificate or a command or expression that gets the certificate.
    #  To find a certificate, use Get-PfxCertificate or use the Get-ChildItem cmdlet in the Certificate (Cert:) drive. If the certificate is not valid or does not have sufficient authority, the command fails.
    [System.Security.Cryptography.X509Certificates.X509Certificate[]]
    $ClientCertificate,

    #  Pass the default credentials
    [switch]$UseDefaultCredentials,

    #  Specifies a user account that has permission to send the request. The default is the current user.
    #  Type a user name, such as "User01" or "Domain01\User01", or enter a PSCredential object, such as one generated by the Get-Credential cmdlet.
    [System.Management.Automation.PSCredential]
    [System.Management.Automation.Credential()]
    [Alias("")]$Credential = [System.Management.Automation.PSCredential]::Empty,

    # Specifies that Authorization: Basic should always be sent. Requires $Credential to be set, and should only be used with https
    [ValidateScript({if(!($Credential -or $WebSession)){ throw "ForceBasicAuth requires the Credential parameter be set"} else { $true }})]
    [switch]$ForceBasicAuth,

    # Uses a proxy server for the request, rather than connecting directly to the Internet resource. Enter the URI of a network proxy server.
    # Note: if you have a default proxy configured in your internet settings, there is no need to set it here.
    [Uri]$Proxy,

    #  Pass the default credentials to the Proxy
    [switch]$ProxyUseDefaultCredentials,

    #  Pass specific credentials to the Proxy
    [System.Management.Automation.PSCredential]
    [System.Management.Automation.Credential()]
    $ProxyCredential= [System.Management.Automation.PSCredential]::Empty     
  )
  dynamicparam {
    $paramDictionary = new-object System.Management.Automation.RuntimeDefinedParameterDictionary
    if(Get-Command Get-ConfigData -ErrorAction SilentlyContinue) {
      foreach( $name in (Get-ConfigData).Keys ){
        if("CommonPath","UserPath" -notcontains $name) {
          $param = new-object System.Management.Automation.RuntimeDefinedParameter( $Name, [Switch], (New-Object Parameter -Property @{ParameterSetName=$Name;Mandatory=$true}))
          $paramDictionary.Add($Name, $param)
        }
      } 
    }
    return $paramDictionary
  }  
  begin {
    if($PSCmdlet.ParameterSetName -ne "InstallPath") {
      $Config = Get-ConfigData
      switch($PSCmdlet.ParameterSetName){
        "UserPath"   { $InstallPath = $Config.UserPath }
        "CommonPath" { $InstallPath = $Config.CommonPath }
        # "SystemPath" { $InstallPath = $Config.SystemPath }
      }
      $PsBoundParameters.Remove(($PSCmdlet.ParameterSetName + "Path"))
      $PsBoundParameters.Add("InstallPath", $InstallPath)
    }
  }
  process {
    if("$Package" -match "^https?://" ) {
      # Make sure the InstallPath has a file name:
      # TODO: This is currently very simplistic, based on the URL alone which
      #       requires the URL to have NO query string, and end in a file name
      #       it would be better to have Invoke-Web figure out the file name...
      if(Test-Path $InstallPath -PathType Container) {
        $OutFile = Join-Path $InstallPath (Split-Path $Package -Leaf)
      } else {
        $OutFile = $InstallPath
      }
      
      Write-Verbose "Fetch '$Package' to '$OutFile'"

      $WebParam = @{} + $PsBoundParameters
      $WebParam.Add("Uri",$Package)
      $WebParam.Add("OutFile",$OutFile)
      $null = "Package", "InstallPath", "Common", "User", "Force", "Import", "Passthru" | % { $WebParam.Remove($_) }

      $Package = Invoke-WebRequest @WebParam -ErrorVariable FourOhFour
      if($FourOhFour){
        $PSCmdlet.ThrowTerminatingError( $FourOhFour[0] )
      }
      # If we used the built-in Invoke-WebRequest, we don't have the file yet...
      if($Package -isnot [System.IO.FileInfo]) { $Package = Get-ChildItem $OutFile }
    }
    # Now lets open it as a package
    $PackagePath = Resolve-Path $Package -ErrorAction Stop

    # TODO: Make this more bullet-proof (it's just testing extensions right now)
    # If we just got back a text file, figure out the real package Uri and recurse
    if($ModuleInfoFile -eq (Split-Path $PackagePath -Leaf)) {
      $Mi = Get-ModuleInfo $PackagePath
      Remove-Item $PackagePath
      if($Mi.PackageUri) {
        Write-Verbose "Found PackageUri '$($Mi.PackageUri)' in Module Info file '$PackagePath' -- Installing by Uri"
        $PsBoundParameters["Package"] = $Mi.PackageUri
        Install-ModulePackage @PsBoundParameters
        return
      }
    }

    $InstallPath = "$InstallPath".TrimEnd("\")

    # Warn them if they're installing in an irregular location
    [string[]]$ModulePaths = $Env:PSModulePath -split ";" | Resolve-Path -ErrorAction SilentlyContinue | Convert-Path -ErrorAction SilentlyContinue
    if(!($ModulePaths -match ([Regex]::Escape($InstallPath) + ".*"))) {
      if((Get-PSCallStack | Where-Object{ $_.Command -eq "Install-ModulePackage" }).Count -le 1) {
        Write-Warning "Install path '$InstallPath' is not in yout PSModulePath!"
        $InstallPath = Select-ModulePath $InstallPath
      }
    }

    # At this point $PackagePath is a local file, but it might be a .zip or .nupkg:
    $Manifest = Get-PackageManifest $PackagePath
    if(!$Manifest) {
      ## TODO: This should be Expand-ZipFile
      if($ModuleFolder = Install-ModuleArchive $PackagePath $InstallPath) {
        $Manifest = Get-ModuleInfo (Join-Path $InstallPath $ModuleFolder.Name)
        if(!$Manifest) {
          Write-Warning "The package was unpacked to $($ModuleFolder.Fullname), but is invalid -- it has no Manifest.psdxml"
        }
      }
    } else {
      ## TODO: Should merge Expand-Package & Expand-ZipFile so there's just Expand-Package
      $ModuleFolder = Expand-Package $PackagePath $InstallPath -Force:$Force -Passthru:$Passthru
    }

    # We need to verify the RequiredModules are available, or install them.
    if($Manifest."ModuleManifest.RequiredModules") {
      $FailedModules = @()
      foreach($RequiredModule in $Manifest."ModuleManifest.RequiredModules".ModuleId) {
        # If the module is available ... 
        $VPR = "SilentlyContinue"
        $VPR, $VerbosePreference = $VerbosePreference, $VPR
        if($Module = Get-Module -Name $RequiredModule.Name -ListAvailable) {
          $VPR, $VerbosePreference = $VerbosePreference, $VPR
          if($Module = $Module | Where-Object { $_.Version -ge $RequiredModule.Version }) {
            if($Import) {
              Import-Module -Name $RequiredModule.Name -MinimumVersion
              continue
            }
          } else {
            Write-Warning "The package $PackagePath requires $($RequiredModule.Version) of the $($RequiredModule.Name) module. Yours is version $($Module.Version). Trying upgrade:"
          }
        } else {
            Write-Warning "The package $PackagePath requires the $($RequiredModule.Name) module. Trying install:"
        }
        # Check for a local copy, maybe we get lucky:
        $Folder = Split-Path $PackagePath
        # Check with and without the version number in the file name:
        if(($RequiredFile = Get-Item (Join-Path $Folder "$($RequiredModule.Name)*$ModulePackageExtension") | 
                              Sort-Object { [IO.Path]::GetFileNameWithoutExtension($_) } | 
                              Select-Object -First 1) -and
           (Get-PackageManifest $RequiredFile).Version -ge $RequiredModule.Version)
        {
          Write-Warning "Installing required module $($RequiredModule.Name) from $RequiredFile"
          Install-ModulePackage $RequiredFile $InstallPath
          continue
        } 
        # If they have a ModuleInfoUri, try that:
        if($RequiredModule.ModuleInfoUri) {
          Write-Warning "Installing required module $($RequiredModule.Name) from $($RequiredModule.ModuleInfoUri)"
          Install-ModulePackage $RequiredModule.ModuleInfoUri $InstallPath
          continue
        } 

        Write-Warning "The module package does not have a ModuleInfoUri for the required module $($RequiredModule.Name), and there's not a local copy."
        $FailedModules += $RequiredModule
        continue
      }
      if($FailedModules) {
        Write-Error "Unable to resolve required modules."
        Write-Output $FailedModules
        return # TODO: Should we install anyway? Prompt?
      }
    }


    if($Import -and $ModuleFolder) {
      Import-Module $ModuleFolder.Name -Passthru:$Passthru
    } elseif($ModuleFolder) {
      Get-Module $ModuleFolder.Name
    }
  }
}

function Get-ModuleInfo {
  #.Synopsis
  #  Get information about a module from the ModuleInfo manifest or the psd1 metadata file.
  [CmdletBinding()]
  param(
    # The name of the module (or path)
    [Parameter(ValueFromPipeline=$true, ValueFromPipelineByPropertyName=$true, Mandatory=$true)]
    [Alias("ModuleInfoPath","ModuleManifestPath","PSPath","Path","Name")]
    $Module
  )
  process {
    [string]$ModuleManifestPath = ""
    [string]$ModuleInfoPath = ""

    # If the parameter isn't already a ModuleInfo object, then let's make it so:
    if($Module -is "string" -or $Module -is [System.IO.FileInfo] -or $Module -is [System.Management.Automation.PathInfo]) {
      if(Split-Path $Module) {
        $ModulePath = Convert-Path $Module -ErrorAction SilentlyContinue -ErrorVariable noPath
        if($noPath) { $ModulePath = $Module }
      } else {
        $ModulePath = $Module
      }
      $Module = $null
      $Extension = [IO.Path]::GetExtension($ModulePath)

      # It should be either a String or a FileInfo (if it's a string, it might begmo)
      Write-Verbose "Switch on Extension: $Extension  ($ModulePath)"
      switch($Extension) {
        ".psd1" {
          Write-Verbose "Finding Module by ModuleManifestPath"
          # We have a path to a .psd1
          $file = Split-Path $ModulePath -Leaf
          if($file -eq $ModuleInfoFile) {
            $ModuleName = Split-Path (Split-Path $ModulePath) -Leaf
            $ModuleInfoPath = $ModulePath
            $ModuleManifestPath = Join-Path (Split-Path $ModulePath) $ModuleName
          } else {
            $ModuleInfoPath  = Join-Path (Split-Path $ModulePath) $ModuleInfoFile
            $ModuleManifestPath = $ModulePath
          }
        }
        ".psmx" {
          Write-Verbose "Finding Module by ModuleManifestPath"
          Get-PackageManifest $ModulePath |
            Add-Member NoteProperty PackagePath $ModulePath -Passthru |
            Add-Member NoteProperty PSPath ("{0}::{1}" -f $ModulePath.Provider, $ModulePath.ProviderPath) -Passthru
          return 
        }
        default {
          Write-Verbose "Finding Module by Module Name: $ModulePath"
          # Hopefully, they've just specified a module name:

          $VPR = "SilentlyContinue"
          $VPR, $VerbosePreference = $VerbosePreference, $VPR
          $Module = Get-Module $ModulePath -ListAvailable
          $VPR, $VerbosePreference = $VerbosePreference, $VPR
          # In this case, there's probably lots of them, so we need to recurse:
          $Module | Get-ModuleInfo
          return
        }
      }

      if(!$Module -and (Test-Path $ModulePath)) {
        Write-Verbose "Searching for Module by Path"
        # They got crazy and passed us a path instead of a name ...
        $ModuleBase = $ModulePath
        if(Test-Path $ModulePath -PathType Leaf) {
          $ModuleBase = Split-Path $ModulePath
        }
        # Hopefully, it's at least in the PSModulePath (or already loaded)
        $VPR = "SilentlyContinue"
        $VPR, $VerbosePreference = $VerbosePreference, $VPR
        $Module = Get-Module (Split-Path $ModuleBase -Leaf) -ListAvailable | Where-Object { $_.ModuleBase -eq $ModuleBase }
        $VPR, $VerbosePreference = $VerbosePreference, $VPR
        # But otherwise, we can always try importing it:
        if(!$Module) {
          Write-Verbose "Finding Module by Import-Module (least optimal method)"
          $Module = Import-Module $ModulePath -Passthru -ErrorAction SilentlyContinue
          if($Module) {
            Remove-Module $Module
          }
        }
      }
    }
    if($Module) {
      $ModuleInfoPath = Join-Path $Module.ModuleBase $ModuleInfoFile
      $ModuleManifestPath = Join-Path $Module.ModuleBase "$($Module.Name)$ModuleManifestExtension"
    }

    if(Test-Path $ModuleInfoPath) {
      Write-Verbose "Loading ModuleManifest"

      Import-LocalizedData -BindingVariable "ModuleInfo" -BaseDirectory $ModuleBase -FileName "Package" -ErrorAction "SilentlyContinue"

      $ModuleInfo = $ModuleInfo | 
         Add-Member NoteProperty ModuleInfoPath $ModuleInfoPath -Passthru | 
         Add-Member NoteProperty ModuleManifestPath $ModuleManifestPath -Passthru | 
         Add-Member NoteProperty Path $ModuleManifestPath -Passthru
      Write-Output $ModuleInfo
    }
    elseif($Module) 
    {
      Write-Verbose "Write out PSModuleInfo"
      Write-Output ($Module | 
                      Add-Member NoteProperty ModuleInfoPath $ModuleInfoPath -Passthru | 
                      Add-Member NoteProperty ModuleManifestPath $ModuleManifestPath -Passthru)
    } 
    else 
    {
      throw "Unable to get ModuleInfo"
    }
  }
}

##### Private functions ######
function Get-PackageManifest {
   # .Synopsis
   # Try reading the module manifest from the package
   [CmdletBinding()]
   param(
      # Path to a package to get information about
      $ModulePath
   )
   end {
      try {
         $Package = [System.IO.Packaging.Package]::Open( (Convert-Path $ModulePath), [IO.FileMode]::Open, [System.IO.FileAccess]::Read )

         ## First load the package manifest (which has URLs in it)
         $Manifest = @($Package.GetRelationshipsByType( $ManifestType ))[0]
         if(!$Manifest -or !$Manifest.TargetUri) {
            Write-Warning "This file is not a valid PoshCode Package, it has not specified the manifest"
            return
         }
         $Part = $Package.GetPart( $Manifest.TargetUri )
         if(!$Part) {
            Write-Warning "This file is not a valid PoshCode Package, it has no manifest at $($Manifest.TargetUri)"
            return
         }
         $PackageManifest = Import-ManifestStream ($Part.GetStream())

         ## Now load the module manifest (which has everything else in it)
         $Manifest = @($Package.GetRelationshipsByType( $ModuleMetadataType ))[0]
         if(!$Manifest -or !$Manifest.TargetUri) {
            Write-Warning "This file is not a valid PoshCode Package, it has not specified the manifest"
            return
         }
         if($Part = $Package.GetPart( $Manifest.TargetUri )) {
            if($ModuleManifest = Import-ManifestStream ($Part.GetStream())) {
               ## If we got the module manifest, update the PackageManifest
               $PackageManifest = Update-Dictionary $ModuleManifest $PackageManifest
            }
         }
         Write-Output $PackageManifest
      } catch [Exception] {
         $PSCmdlet.WriteError( (New-Object System.Management.Automation.ErrorRecord $_.Exception, "Unexpected Exception", "InvalidResult", $_) )
      } finally {
         $Package.Close()
         $Package.Dispose()
      }
  }
}


function Import-ManifestStream {
   #  .Synopsis
   #  Import a manifest from an IO Stream
   param(
      [Parameter(ValueFromPipeline=$true, Mandatory=$true)]
      [System.IO.Stream]$stream
   )   
   try {
      $reader = New-Object System.IO.StreamReader $stream
      # This gets the ModuleInfo
      Import-Manifest ($reader.ReadToEnd())
   } catch [Exception] {
      $PSCmdlet.WriteError( (New-Object System.Management.Automation.ErrorRecord $_.Exception, "Unexpected Exception", "InvalidResult", $_) )
   } finally {
      if($reader) {
         $reader.Close()
         $reader.Dispose()
      }
      if($stream) {
         $stream.Close()
         $stream.Dispose()
      }
   }
}

function Import-Manifest {
   #  .Synopsis
   #  Parse a module manifest the best way we can.
   param(
      [Parameter(ValueFromPipeline=$true, Mandatory=$true)]
      [string]$Manifest
   )
   begin {
      $ValidTokens = "GroupStart", "GroupEnd", "Member", "Operator", "String", "Comment", "NewLine", "StatementSeparator"
      $ParseErrors = $Null
   }
   process {
      if(Test-Path $Manifest) {
         $Manifest = Convert-Path $Manifest
         Import-LocalizedData -BaseDirectory (Split-Path $Manifest) -FileName (Split-Path $Manifest -Leaf)
      } else {
         $Tokens = [System.Management.Automation.PSParser]::Tokenize($Manifest,[ref]$ParseErrors)
         if($ParseErrors -ne $null) {
            $PSCmdlet.WriteError( (New-Object System.Management.Automation.ErrorRecord "Parse error reading package manifest", "Parse Error", "InvalidData", $ParseErrors) )
            return
         }
         if($InvalidTokens = $Tokens | Where-Object { $ValidTokens -notcontains $_.Type }){
            $PSCmdlet.WriteError( (New-Object System.Management.Automation.ErrorRecord "Invalid Tokens found when parsing package manifest", "Parse Error", "InvalidData", $InvalidTokens) )
            return
         }
         # Even with this much protection, Invoke-Expression makes me nervous, which is why I try to avoid it.
         Invoke-Expression "Data { ${Manifest} } "
      }
   }

}


function Copy-Stream {
  #.Synopsis
  #   Copies data from one stream to another
  param(
    # The source stream to read from
    [IO.Stream]
    $reader,

    # The destination stream to write to
    [IO.Stream]
    $writer,

    [string]$Activity = "File Packing",

    [Int]
    $Length = 0
  )
  end {
    $bufferSize = 0x1000 
    [byte[]]$buffer = new-object byte[] $bufferSize
    [int]$sofar = [int]$count = 0
    while(($count = $reader.Read($buffer, 0, $bufferSize)) -gt 0)
    {
      $writer.Write($buffer, 0, $count);

      $sofar += $count
      if($Length -gt 0) {
         Write-Progress -Activity $Activity  -Status "Copied $sofar of $Length" -ParentId 0 -Id 1 -PercentComplete (($sofar/$Length)*100)
      } else {
         Write-Progress -Activity $Activity  -Status "Copied $sofar bytes..." -ParentId 0 -Id 1
      }
    }
    Write-Progress -Activity "File Packing" -ParentId 0 -Id 1 -Complete
  }
}

function Select-ModulePath {
  #.Synopsis
  #   Interactively choose (and validate) a folder from the Env:PSModulePath
  [CmdletBinding(SupportsShouldProcess=$true, ConfirmImpact="High")]
  param(
    # The folder to install to. This folder should be one of the ones in the PSModulePath, NOT a subfolder.
    $InstallPath
  )
  end {
    $ChoicesWithHelp = @()
    [Char[]]$Letters = @("P","O","C")
    [Char]$Letter = "A"
    $default = -1
    $index = -1
    $common = 0

    $PSModulePath = $Env:PSModulePath -split ";" | ? {$_} 

    Write-Verbose ("`n" + ($PSModulePath -join "`n"))
    switch -Wildcard ((@($Env:PSModulePath -split ";") + $InstallPath) | ? {$_} | Select -Unique) {
      "${PSHome}*" {
        Write-Verbose "Skipping '$_' we do not support installing to the System location."
        ##### We do not support installing to the System location. #####
        #$index++
        #$ChoicesWithHelp += New-Object System.Management.Automation.Host.ChoiceDescription "S&ystem", $_
        continue
      }
      "$(Split-Path $PROFILE)*" {
        $index++
        $ChoicesWithHelp += New-Object System.Management.Automation.Host.ChoiceDescription "&Profile", $_
        $default = $index
        continue
      }
      "$(Join-Path ([Environment]::GetFolderPath("ProgramFiles")) \WindowsPowerShell\Modules)" {
        $index++
        $K, $C = $( if($common -lt 1){"&Common","C"}elseif($common -lt 2){"Co&mmon","M"}else{"Commo&n","N"} )
        $ChoicesWithHelp += New-Object System.Management.Automation.Host.ChoiceDescription $K, $_
        $Letters += $C
        $common++
        if($Default -lt 0){$Default = $index}
        continue
      }
      "$(Join-Path ([Environment]::GetFolderPath("CommonProgramFiles")) Modules)*" {
        $index++
        $K, $C = $( if($common -lt 1){"&Common","C"}elseif($common -lt 2){"Co&mmon","M"}else{"Commo&n","N"} )
        $ChoicesWithHelp += New-Object System.Management.Automation.Host.ChoiceDescription $K, $_
        $Letters += $C
        $common++
        if($Default -lt 0){$Default = $index}
        continue
      }
      "$(Join-Path ([Environment]::GetFolderPath("CommonDocuments")) Modules)*" {
        $index++
        $K, $C = $( if($common -lt 1){"&Common","C"}elseif($common -lt 2){"Co&mmon","M"}else{"Commo&n","N"} )
        $ChoicesWithHelp += New-Object System.Management.Automation.Host.ChoiceDescription $K, $_
        $Letters += $C
        $common++
        if($Default -lt 0){$Default = $index}
        continue
      }
      "$([Environment]::GetFolderPath("MyDocuments"))*" { 
        $index++
        $ChoicesWithHelp += New-Object System.Management.Automation.Host.ChoiceDescription "My&Documents", $_
        $Letters += "D"
        if($Default -lt 0){$Default = $index}
        continue
      }
      default {
        $index++
        $Key = $_ -replace [regex]::Escape($Env:USERPROFILE),'~' -replace "((?:[^\\]*\\){2}).+((?:[^\\]*\\){2})",'$1...$2'
        $Characters = ($Key -replace "\W").ToCharArray() | Select -Unique
        Write-Verbose "Characters: $(($Characters | ? { $Letters -notcontains $_ } ) -join '')"
        $Found = $False
        foreach($c in $Characters) {
          if($Letters -notcontains $c) {
            $Letters += $c
            $Key = $Key -replace "(${c})(.*)","&`$1`$2"
            $ChoicesWithHelp += New-Object System.Management.Automation.Host.ChoiceDescription $Key, $_
            $Found = $True
            break
          }
        }
        if(!$Found) {
          while($Letters -contains $Letter) { 
            $Letter = 1 + $Letter
            $Letters += $Letter
          }
          $ChoicesWithHelp += New-Object System.Management.Automation.Host.ChoiceDescription "&$Letter $Key", $_
        }
        continue
      }
    }
  
    Write-Verbose ("`n" + ($ChoicesWithHelp | ft -auto| Out-String))

    if($InstallPath) { $default = $index }

    # Let's try and make sure they have one of our two known "Common" locations:
    if($common -lt 1) {
      $index++
      $ChoicesWithHelp += New-Object System.Management.Automation.Host.ChoiceDescription "&Common", "$([Environment]::GetFolderPath("ProgramFiles"))\WindowsPowerShell\Modules"
    }
    # And we always offer the "Other" location:
    $index++
    $ChoicesWithHelp += New-Object System.Management.Automation.Host.ChoiceDescription "&Other", "Type in your own path!"

    if($PSModulePath -notcontains $InstallPath) {
      Write-Warning "InstallPath '$InstallPath' is not in your PSModulePath."

      do {
        if($InstallPath -and !(Test-Path $InstallPath)){
          if($PSCmdlet.ShouldProcess(
            "Verifying module install path '$InstallPath'", 
            "Create folder '$InstallPath'?", 
            "Creating Module Install Path" )) {

            $null = New-Item -Type Directory -Path $InstallPath -Force -ErrorVariable FailMkDir
          
            ## Handle the error if they asked for -Common and don't have permissions
            if($FailMkDir -and @($FailMkDir)[0].CategoryInfo.Category -eq "PermissionDenied") {
              Write-Warning "You do not have permission to install a module to '$InstallPath\$ModuleName'. You may need to be elevated. (Press Ctrl+C to cancel)"
            } else {
              continue
            }
          }
        }

        $Answer = $Host.UI.PromptForChoice(
          "Please choose an install path.",
          "Choose a Module Folder (use ? to see the full paths)",
          ([System.Management.Automation.Host.ChoiceDescription[]]$ChoicesWithHelp),
          $Default)

        if($Answer -ge $index) {
          $InstallPath = Read-Host ("You should pick a path that's already in your PSModulePath. " + 
                                    "To choose again, press Enter.`n" +
                                    "Otherwise, type the path for a 'Modules' folder you want to create")
        } else {
          $InstallPath = $ChoicesWithHelp[$Answer].HelpMessage
        }
      } while(!$InstallPath -or !(Test-Path $InstallPath))
    }
    return $InstallPath
  }
}

function Test-ExecutionPolicy {
  #.Synopsis
  #   Validate the ExecutionPolicy
  param()

  $Policy = Get-ExecutionPolicy
  if(([Microsoft.PowerShell.ExecutionPolicy[]]"Restricted","Default") -contains $Policy) {
    $Warning = "Your execution policy is $Policy, so you will not be able import script modules."
  } elseif(([Microsoft.PowerShell.ExecutionPolicy[]]"AllSigned") -eq $Policy) {
    $Warning = "Your execution policy is $Policy, if modules are not signed, you won't be able to import them."
  }
  if($Warning) {
    Write-Warning ("$Warning`n" +
        "You may want to change your execution policy to RemoteSigned, Unrestricted or even Bypass.`n" +
        "`n" +
        "        PS> Set-ExecutionPolicy RemoteSigned`n" +
        "`n" +
        "For more information, read about execution policies by executing:`n" +
        "        `n" +
        "        PS> Get-Help about_execution_policies`n")
  } elseif(([Microsoft.PowerShell.ExecutionPolicy]"Unrestricted") -eq $Policy) {
    Write-Host "Your execution policy is $Policy and should be fine. Note that modules flagged as internet may still cause warnings."
  } elseif(([Microsoft.PowerShell.ExecutionPolicy]"RemoteSigned") -contains $Policy) {
    Write-Host "Your execution policy is $Policy and should be fine. Note that modules flagged as internet will not load if they're not signed."
  } 
}

function Expand-ZipFile {
  #.Synopsis
  #   Expand a zip file, ensuring it's contents go to a single folder ...
  [CmdletBinding(SupportsShouldContinue=$true)]
  param(
    # The path of the zip file that needs to be extracted
    [Parameter(Position=0, Mandatory=$true, ValueFromPipelineByPropertyName=$true)]
    [Alias("PSPath")]
    $FilePath,

    # The base path where we want the output folder to end up
    [Parameter(Position=1)] 
    $OutputPath,

    # Make sure the resulting folder is always named the same as the archive
    [Switch]$Force
  )
  process {
    $ZipFile = Get-Item $FilePath -ErrorAction Stop
    $OutputFolderName = $ZipFile.BaseName

    # Figure out where we'd prefer to end up:
    if(Test-Path $OutputPath -Type Container) {
      # If they pass a path that exists, resolve it:
      $OutputPath = Convert-Path $OutputPath

      # If it's not empty, assume they want us to make a folder there:
      if(Get-ChildItem $OutputPath) {
        $Destination = (New-Item (Join-Path $OutputPath $OutputFolderName) -Type Directory -Force).FullName
        # Otherwise, we could just use that folder (maybe):
      } else {
        $Destination = $OutputPath
      }
    } else {
      # Otherwise, assume they want us to make a new folder:
      $Destination = (New-Item $OutputPath -Type Directory -Force).FullName
    }

    if("System.IO.Compression.ZipFile" -as [Type]) {
      # If we have .Net 4, this is better (no GUI)
      try {
        $Archive = [System.IO.Compression.ZipFile]::Open( $ZipFile.FullName, "Read" )
        [System.IO.Compression.ZipFileExtensions]::ExtractToDirectory( $Archive, $Destination )
      } catch { Write-Error $_.Message } finally {
        $Archive.Dispose()
      }
    } else {
      # Note: the major problem with this method is that it has GUI!
      $shellApplication = new-object -com Shell.Application
      $zipPackage = $shellApplication.NameSpace($ZipFile.FullName)
      $shellApplication.NameSpace($Destination).CopyHere($zipPackage.Items())
    }

    # Now, a few corrective options:
    # If there are no items, bail.
    $RootItems = @(Get-ChildItem $Destination)
    $RootItemCount = $RootItems.Count
    if($RootItemCount -lt 1) {
      throw "There were no items in the Archive: $($ZipFile.FullName)"
    }

    # If there's nothing there but another folder, move it up one.
    while($RootItemCount -eq 1 -and $RootItems[0].PSIsContainer) {
      Write-Verbose "Extracted One Folder ($RootItems) - Moving"
      if($Force -or ($RootItems[0].Name -eq (Split-Path $Destination -Leaf))) { 
        # Keep the archive named folder
        Move-Item (join-path $RootItems[0].FullName *) $destination
        # Remove the child folder
        Remove-Item $RootItems[0].FullName
      } else {

        $NewDestination = (Join-Path (Split-Path $Destination) $RootItems[0].Name)
        if(Test-Path $NewDestination) {
          if(Get-ChildItem $NewDestination) {
            if($Force -or $PSCmdlet.ShouldContinue("The OutputPath exists and is not empty. Do you want to replace the contents of '$NewDestination'?", "Deleting contents of '$NewDestination'")) {
              Remove-Item $NewDestination -Recurse -ErrorAction Stop
            } else {
              throw "OutputPath '$NewDestination' Exists and is not empty."
            }
          }
          # move the contents to the new location
          Move-Item (join-path $RootItems[0].FullName *) $NewDestination
          Remove-Item $RootItems[0].FullName
        } else {
          # move the whole folder to the new location
          Move-Item $RootItems[0].FullName (Split-Path $NewDestination -Leaf)
        }
        Remove-Item $Destination
        $Destination = $NewDestination
      }

      $RootItems = @(Get-ChildItem $Destination)
      $RootItemCount = $RootItems.Count
      if($RootItemCount -lt 1) {
        throw "There were no items in the Archive: $($ZipFile.FullName)"
      }
    }
    # Output the new folder
    Get-Item $Destination
  }
}

function Expand-Package {
  #.Synopsis
  #   Expand a zip file, ensuring it's contents go to a single folder ...
  [CmdletBinding(SupportsShouldContinue=$true)]
  param(
    # The path of the module package that needs to be extracted
    [Parameter(Position=0, Mandatory=$true, ValueFromPipelineByPropertyName=$true)]
    [Alias("PSPath")]
    $PackagePath,

    # The base path where we want the module folder to end up
    [Parameter(Position=1)] 
    $InstallPath,

    # If set, overwrite existing modules without prompting
    [Switch]$Force,

    # If set, output information about the files as well as the module 
    [Switch]$Passthru    
  )
  begin {
    if(!(Test-Path variable:RejectAllOverwriteOnInstall)){
      $RejectAllOverwriteOnInstall = $false;
      $ConfirmAllOverwriteOnInstall = $false;
    }
  }
  process {
    try {
      $Package = [System.IO.Packaging.Package]::Open( $PackagePath, "Open", "Read" )
      Write-Host ($Package.PackageProperties|Select-Object Title,Version,@{n="Guid";e={$_.Identifier}},Creator,Description, @{n="Package";e={$PackagePath}}|Out-String)

      $ModuleResult = $ModuleName = $Package.PackageProperties.Title
      if($InstallPath -match ([Regex]::Escape($ModuleName)+'$')) {
        $InstallPath = Split-Path $InstallPath
      }

      if($PSCmdlet.ShouldProcess("Extracting the module '$ModuleName' to '$InstallPath\$ModuleName'", "Extract '$ModuleName' to '$InstallPath\$ModuleName'?", "Installing $($ModuleName)" )) {
        if($Force -Or !(Test-Path "$InstallPath\$ModuleName" -ErrorAction SilentlyContinue) -Or $PSCmdlet.ShouldContinue("The module '$InstallPath\$ModuleName' already exists, do you want to replace it?", "Installing $ModuleName", [ref]$ConfirmAllOverwriteOnInstall, [ref]$RejectAllOverwriteOnInstall)) {
          $success = $false
          if(Test-Path "$InstallPath\$ModuleName") {
            Remove-Item "$InstallPath\$ModuleName" -Recurse -Force -ErrorAction Stop
          }
          $ModuleResult = New-Item -Type Directory -Path "$InstallPath\$ModuleName" -Force -ErrorVariable FailMkDir
          
          ## Handle the error if they asked for -Common and don't have permissions
          if($FailMkDir -and @($FailMkDir)[0].CategoryInfo.Category -eq "PermissionDenied") {
            throw "You do not have permission to install a module to '$InstallPath\$ModuleName'. You may need to be elevated."
          }

          foreach($part in $Package.GetParts() | where Uri -match ("^/" + $ModuleName)) {
            $fileSuccess = $false
            # Copy the data to the file system
            try {
              if(!(Test-Path ($Folder = Split-Path ($File = Join-Path $InstallPath $Part.Uri)) -EA 0) ){
                $null = New-Item -Type Directory -Path $Folder -Force
              }
              Write-Verbose "Unpacking $File"
              $writer = [IO.File]::Open( $File, "Create", "Write" )
              $reader = $part.GetStream()

              Copy-Stream $reader $writer -Activity "Writing $file"
              $fileSuccess = $true
            } catch [Exception] {
              $PSCmdlet.WriteError( (New-Object System.Management.Automation.ErrorRecord $_.Exception, "Unexpected Exception", "InvalidResult", $_) )
            } finally {
              if($writer) {
                $writer.Close()
                $writer.Dispose()
              }
              if($reader) {
                $reader.Close()
                $reader.Dispose()
              }
            }
            if(!$fileSuccess) { throw "Couldn't unpack to $File."}
            if($Passthru) { Get-Item $file }
          }
          $success = $true
        } else { # !Force
          $Import = $false # Don't _EVER_ import if they refuse the install
        }        
      } # ShouldProcess
      if(!$success) { $PSCmdlet.WriteError( (New-Object System.Management.Automation.ErrorRecord (New-Object System.Management.Automation.HaltCommandException "Can't overwrite $ModuleName module: User Refused"), "ShouldContinue:False", "OperationStopped", $_) ) }
    } catch [Exception] {
      $PSCmdlet.WriteError( (New-Object System.Management.Automation.ErrorRecord $_.Exception, "Unexpected Exception", "InvalidResult", $_) )
    } finally {
      $Package.Close()
      $Package.Dispose()
    }
    if($success) {
      Write-Output $ModuleResult
    }
  }
}

# FULL # BEGIN FULL: These cmdlets are only needed in the full version of the module

function Get-Module {
  [CmdletBinding(DefaultParameterSetName='Loaded', HelpUri='http://go.microsoft.com/fwlink/?LinkID=141552')]
  param(
      [Parameter(ParameterSetName='PsSession', Position=0, ValueFromPipeline=$true)]
      [Parameter(ParameterSetName='Available', Position=0, ValueFromPipeline=$true)]
      [Parameter(ParameterSetName='CimSession', Position=0, ValueFromPipeline=$true)]
      [Parameter(ParameterSetName='Loaded', Position=0, ValueFromPipeline=$true)]
      [string[]]
      ${Name},

      [Parameter(ParameterSetName='Available')]
      [Parameter(ParameterSetName='Loaded')]
      [switch]
      ${All},

      [Parameter(ParameterSetName='PsSession')]
      [Parameter(ParameterSetName='CimSession')]
      [Parameter(ParameterSetName='Available', Mandatory=$true)]
      [switch]
      ${ListAvailable},

      [Parameter(ParameterSetName='CimSession')]
      [Parameter(ParameterSetName='Available')]
      [Parameter(ParameterSetName='PsSession')]
      [switch]
      ${Refresh},

      [Parameter(ParameterSetName='PsSession', Mandatory=$true)]
      [ValidateNotNull()]
      [System.Management.Automation.Runspaces.PSSession]
      ${PSSession},

      [Parameter(ParameterSetName='CimSession', Mandatory=$true)]
      [ValidateNotNull()]
      [Microsoft.Management.Infrastructure.CimSession]
      ${CimSession},

      [Parameter(ParameterSetName='CimSession')]
      [ValidateNotNull()]
      [uri]
      ${CimResourceUri},

      [Parameter(ParameterSetName='CimSession')]
      [ValidateNotNullOrEmpty()]
      [string]
      ${CimNamespace})

  begin
  {
    function Local:Update-ModuleInfo {
      [CmdletBinding()]param([Parameter(ValueFromPipeline=$true)]$ModuleInfo)
      process {
        if($ModuleInfo) {
          $ModulePath = Split-Path $ModuleInfo.Path
          $PackageInfo = @{}
          ## This is the PoshCode metadata file: Package.psd1
          Import-LocalizedData -BindingVariable "PackageInfo" -BaseDirectory $ModulePath -FileName "Package" -ErrorAction "SilentlyContinue"
          Write-Verbose "Loading package info from path: $ModulePath\Package.psd1"
          if($PackageInfo) {
            Update-Dictionary $ModuleInfo $PackageInfo
          } else {
            Write-Output $ModuleInfo
          }
        }
      }
    }

    try {
      $outBuffer = $null
      if ($PSBoundParameters.TryGetValue('OutBuffer', [ref]$outBuffer))
      {
          $PSBoundParameters['OutBuffer'] = 1
      }
      $wrappedCmd = $ExecutionContext.InvokeCommand.GetCommand('Get-Module',  [System.Management.Automation.CommandTypes]::Cmdlet)
      $scriptCmd = {& $wrappedCmd @PSBoundParameters | Update-ModuleInfo }
      $steppablePipeline = $scriptCmd.GetSteppablePipeline($myInvocation.CommandOrigin)
      $steppablePipeline.Begin($PSCmdlet)
    } catch {
      throw
    }
  }

  process
  {
      try {
         $steppablePipeline.Process($_)
      } catch {
         throw
      }
  }

  end
  {
      try {
         $steppablePipeline.End()
      } catch {
         throw
      }
  }
  <#
    .ForwardHelpTargetName Get-Module
    .ForwardHelpCategory Cmdlet
  #>
}


function Update-Dictionary {
   param(
      $Authoritative,
      $Additional
   )
   ## TODO: Rewrite this generically to deal with arrays of hashtables based on a $KeyField parameter
   foreach($prop in $Additional.GetEnumerator()) {
      #    $value = $(
      #       if($Value -isnot [System.Collections.IDictionary] -and $Value -is [System.Collections.IList]) {
      #          foreach($value in $prop.Value) { $value }
      #       } else { $prop.Value }
      #    )
      #    if($Value -is [System.Collections.IDictionary]) {
      #    ....

      # So far we only have special handling for RequiredModules:
      Write-Verbose "Updating $($prop.Name)"
      switch($prop.Name) {
         "RequiredModules" {
            [string[]]$rmNames = @($Authoritative.RequiredModules) | ForEach-Object { if($_.Name){$_.Name}else{$_.ModuleName} }
            Write-Verbose "Module Requires: $($rmNames -join ',')"
            # The only reason to bother with RequiredModules is if they have a ModuleInfoUri
            foreach($depInfo in @($Additional.RequiredModules | Where-Object { $_.ModuleInfoUri })) {
               $name = $(if($depInfo.ModuleName){$depInfo.ModuleName}else{$depInfo.Name})
               Write-Verbose "PackageInfo Requires: $name"
               # If this Required Module is already listed, then just add the uri
               # Otherwise should we add it? (as a hashtable with the info we have?)
               if($rmNames -contains $name) {
                  foreach($required in $Authoritative.RequiredModules) {
                     if($required.Name -eq $name -or $required.ModuleName -eq $name) {
                        Write-Verbose "Update RequiredModule ($name) with ModuleInfoUri ($($depInfo.ModuleInfoUri))"
                        if($required -is [System.Collections.IDictionary]) {
                           if(!$required.Contains("ModuleInfoUri")) {
                              $required.Add("ModuleInfoUri", $depInfo.ModuleInfoUri)
                           }
                        } else {
                           Add-Member -InputObject $required -Type NoteProperty -Name "ModuleInfoUri" -Value $depInfo.ModuleInfoUri
                        }
                     }
                  }
               }
            }
         }
         default {
            ## We only add properties, never replace, so hide errors
            if($Authoritative -is [System.Collections.IDictionary]) {
               if(!$Authoritative.Contains($prop.Name)) {
                  $Authoritative.Add($prop.Name, $prop.Value)
               }
            } else {
               Add-Member -in $Authoritative -type NoteProperty -Name $prop.Name -Value $prop.Value -ErrorAction SilentlyContinue
            }            
         }
      }
   }
   $Authoritative
}


function Update-Module {
  #.Synopsis
  #   Checks if you have the latest version of each module
  #.Description
  #   Test the ModuleInfoUri indicate if there's an upgrade available
  [CmdletBinding(SupportsShouldProcess=$true, ConfirmImpact="Medium")]
  param(
    # The name of the module to package
    [Parameter(ValueFromPipeline=$true)]
    [ValidateNotNullOrEmpty()] 
    $Module = "*",

    # Only test to see if there are updates available (don't do the actual updates)
    # This is similar to -WhatIf, except it outputs objects you can examine...
    [Switch]$TestOnly,

    # Force an attempt to update even modules which don't have a ModuleInfoUri
    [Switch]$Force,

    #  Specifies the client certificate that is used for a secure web request. Enter a variable that contains a certificate or a command or expression that gets the certificate.
    #  To find a certificate, use Get-PfxCertificate or use the Get-ChildItem cmdlet in the Certificate (Cert:) drive. If the certificate is not valid or does not have sufficient authority, the command fails.
    [System.Security.Cryptography.X509Certificates.X509Certificate[]]
    $ClientCertificate,

    #  Pass the default credentials
    [switch]$UseDefaultCredentials,

    #  Specifies a user account that has permission to send the request. The default is the current user.
    #  Type a user name, such as "User01" or "Domain01\User01", or enter a PSCredential object, such as one generated by the Get-Credential cmdlet.
    [System.Management.Automation.PSCredential]
    [System.Management.Automation.Credential()]
    [Alias("")]$Credential = [System.Management.Automation.PSCredential]::Empty,

    # Specifies that Authorization: Basic should always be sent. Requires $Credential to be set, and should only be used with https
    [ValidateScript({if(!($Credential -or $WebSession)){ throw "ForceBasicAuth requires the Credential parameter be set"} else { $true }})]
    [switch]$ForceBasicAuth,

    # Uses a proxy server for the request, rather than connecting directly to the Internet resource. Enter the URI of a network proxy server.
    # Note: if you have a default proxy configured in your internet settings, there is no need to set it here.
    [Uri]$Proxy,

    #  Pass the default credentials to the Proxy
    [switch]$ProxyUseDefaultCredentials,

    #  Pass specific credentials to the Proxy
    [System.Management.Automation.PSCredential]
    [System.Management.Automation.Credential()]
    $ProxyCredential= [System.Management.Automation.PSCredential]::Empty  

  )
  process {
    $ModuleInfo = Get-ModuleInfo $Module | Add-Member NoteProperty Update -Value "Unknown" -Passthru

    if(!$Force) {
      # Unless they -Force, filter out modules without manifests
      $ModuleInfo = $ModuleInfo | Where-Object {$_.ModuleInfoUri}
    }

    Write-Verbose "Testing for new versions of $(@($ModuleInfo).Count) modules."
    foreach($M in $ModuleInfo){
      Write-Progress "Updating module $($M.Name)" "Checking for new version (current: $($M.Version))" -id 0
      if(!$M.ModuleInfoUri) {
        # TODO: once the search domain is up, we need to do a search here.
        Write-Warning "Unable to check for update to $($M.Name) because there is no ModuleInfoUri"
        continue
      }

      ## Download the ModuleInfoUri and see what version we got...
      $WebParam = @{Uri = $M.ModuleInfoUri}
      # TODO: This is currently very simplistic, based on the URL alone which
      #       requires the URL to have NO query string, and end in a file name
      #       it would be better to have Invoke-Web figure out the file name...
      $WebParam.OutFile = Join-Path ([IO.path]::GetTempPath()) (Split-Path $M.ModuleInfoUri -Leaf)
      try { # A 404 is a terminating error, but I want to handle it my way.
        $VPR = "SilentlyContinue"
        $VPR, $VerbosePreference = $VerbosePreference, $VPR
        $ModuleInfoFile = Invoke-WebRequest @WebParam -ErrorVariable WebException -ErrorAction SilentlyContinue
      } catch [System.Net.WebException]{
        if(!$WebException) { $WebException = $_.Exception }
      } finally {
        $VPR, $VerbosePreference = $VerbosePreference, $VPR
      }
      if($WebException){
        Write-Warning "Can't fetch ModuleInfo from $($M.ModuleInfoUri) for $($M.Name): $(@($WebException)[0].Message)"
        continue # Check the rest of the modules...
      }

      # If we used the built-in Invoke-WebRequest, we don't have the file yet...
      if($ModuleInfoFile -isnot [System.IO.FileInfo]) { $ModuleInfoFile = Get-ChildItem $WebParam.OutFile }
    
      # Now lets find out what the latest version is:
      $ModuleInfoFile = Resolve-Path $ModuleInfoFile -ErrorAction Stop
      $Mi = Get-ModuleInfo $ModuleInfoFile

      $M.Update = [Version]$Mi.Version
      Write-Verbose "Latest version of $($M.Name) is $($mi.Version)"

      $InstallPath = ""
      # They're going to want to install it where it already is:
      $Paths = $Env:PSModulePath -split "\s*\\?;\s*" | %{ $_.TrimEnd("/\ ") } | sort-object length -desc
      foreach($Path in $Paths) {
        if($M.ModuleManifestPath.StartsWith($Path)) {
          $InstallPath = $Path
          break
        }
      }

      # If we need to update ...
      if(!$TestOnly -and $M.Update -gt $M.Version) {

        if($PSCmdlet.ShouldProcess("Upgrading the module '$($M.Name)' from version $($M.Version) to $($M.Update)", "Update '$($M.Name)' from version $($M.Version) to $($M.Update)?", "Updating $($M.Name)" )) {
          if(!$InstallPath) {
            $InstallPath = Split-Path (Split-Path $M.ModuleManifestPath)
          }

          $InstallParam = @{InstallPath = $InstallPath} + $PsBoundParameters
          $null = "Module", "TestOnly" | % { $InstallParam.Remove($_) }

          # If the InfoUri and the PackageUri are the same, then we already downloaded it
          if($M.ModuleInfoUri -eq $Mi.PackageUri) {
            $InstallParam.Add("Package", $ModuleInfoFile)
          } else {
            # Get rid of the temporarily downloaded package info
            Remove-Item $ModuleInfoFile
            $InstallParam.Add("Package", $Mi.PackageUri)
          }

          Install-ModulePackage @InstallParam
        }
      } elseif($TestOnly) {
        $M | Select-Object Name, Author, Version, Update, PackageUri, ModuleInfoUri, ModuleInfoPath, @{name="PSModulePath";expression={$InstallPath}}
      }
    }
  }
}

function Install-ModuleArchive {
  #.Synopsis
  #   Install a module package to the module 
  [CmdletBinding(SupportsShouldProcess=$true, ConfirmImpact="High", DefaultParameterSetName="UserPath")]
  param(
    # The package file to be installed
    [Parameter(ValueFromPipeline=$true, ValueFromPipelineByPropertyName=$true, Mandatory=$true, Position=0)]
    [Alias("PSPath","PackagePath")]
    $ZipFile,

    # The PSModulePath to install to
    [Parameter(ParameterSetName="InstallPath", Mandatory=$true, Position=1)]
    [Alias("PSModulePath")]
    $InstallPath,

    [Switch]$Force
  )

  $ZipFile = (Resolve-Path $ZipFile -ErrorAction Stop).Path

  $ModuleName = [IO.Path]::GetFileNameWithoutExtension($ZipFile)
  if($InstallPath -notmatch ([Regex]::Escape($ModuleName)+'$')) {
    $InstallPath = Join-Path $InstallPath $ModuleName
  }

  Write-Verbose "Expand ZipFile '$ZipFile' to '$InstallPath'"
  # NOTE: This could change the output folder (if the module inside isn't named the same as the zip)
  $InstallPath = Expand-ZipFile $ZipFile $InstallPath


  $ModulePath = $InstallPath
  $Children = Get-ChildItem $InstallPath
  # if there were .psd1 files in the root, one of them should be the module name!
  if($metadata = ($Children | Select-Object -Expand FullName) -like "*.psd1") {
    # if one of them matches the module name, everything is ok, and we're done!
    if($metadata | Where-Object { $_.BaseName -eq $ModuleName }) {
      Get-Item $ModulePath
    } else {
      # if none of them match, we probably just need to rename the folder:
      if(@($metadata).Count -eq 1) {
        $ModulePath = Join-Path (Split-Path $InstallPath) ([IO.Path]::GetFileNameWithoutExtension($metadata))
      } else {
        # TODO: otherwise, pick one somehow...
        $FileString = $(foreach($BaseName in $InstallPath | % { $_.BaseName }) {
          Get-ChildItem (Join-Path $InstallPath "${BaseName}.*")
        }) | Format-Table | Out-String -Stream

        Write-Host $FileString
        $Name = Read-Host "Please enter the real name of this module:"
        $Module = Get-ChildItem (Join-Path $InstallPath "${Name}.*") -Filter "*.psd1"
        if(!$Module) {
          $Module = Get-ChildItem (Join-Path $InstallPath "${Name}.*") -Filter "*.psm1"
        }
        if($Module) {
          $Name = $Module.BaseName
        }
        $ModulePath = Join-Path (Split-Path $InstallPath) ([IO.Path]::GetFileNameWithoutExtension($Name))
      }
      Write-Verbose "Desired Module Path: $ModulePath"
      if("$InstallPath" -ne "$ModulePath") {
        if(Test-Path $ModulePath) {
          if($Force -or $PSCmdlet.ShouldContinue("The InstallPath exists, are you sure you want to overwrite '$ModulePath'?", "Deleting contents of '$ModulePath'")) {
            Remove-Item $ModulePath -Recurse -ErrorAction Stop
          } else {
            throw "InstallPath '$InstallPath' Exists."
          }
        }
        Rename-Item $InstallPath $ModulePath
      }
      Get-Item $ModulePath
    }
  # Otherwise, if there are no files, the folder(s) must be modules, let's move them and give up.
  } elseif(!($Children | Where-Object { !$_.PSIsContainer })) {
    Write-Verbose "Module $InstallPath contains multiple modules:"
    $TemporaryFolder = $InstallPath
    $InstallPath = Split-Path $InstallPath
    foreach($child in $Children) {
      $ChildModulePath = Join-Path $InstallPath $child.Name
      Write-Verbose "Extracting $ChildModulePath"
      if(Test-Path $ChildModulePath) {
        if($Force -or $PSCmdlet.ShouldContinue("The Module $($Child.Name) exists, are you sure you want to overwrite '$ChildModulePath'?", "Deleting contents of '$ChildModulePath'")) {
          Remove-Item $ChildModulePath -Recurse -ErrorAction Stop
          Move-Item $Child.FullName -Destination $ChildModulePath -Passthru
        } else {
          Write-Warning "Leaving $($Child.Name) in '$($Child.PSParentPath)'"
        }
      } else {
        Move-Item $Child.FullName -Destination $ChildModulePath -Passthru
      }
    }
    # If we moved everything out, then clean up after ourselves.
    if(!(Get-ChildItem $TemporaryFolder)) {
      Remove-Item $TemporaryFolder
    }
  }
}

# FULL # END FULL

Export-ModuleMember -Function Install-ModulePackage, Install-ModuleArchive, Update-Module, Get-Module, Get-PackageManifest, Copy-Stream -Alias * -Variable *
