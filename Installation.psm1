# We're not using Requires because it gets in the way on PSv2
#!Requires -Version 2 -Modules "Configuration"
###############################################################################
## Copyright (c) 2013 by Joel Bennett, all rights reserved.
## Free for use under MS-PL, MS-RL, GPL 2, or BSD license. Your choice. 
###############################################################################
## Installation.psm1 defines the core commands for installing packages:
## Get-ModuleInfo and Install-ModulePackage 
## It depends on the Configuration module and the Invoke-WebRequest cmdlet
Add-Type -Assembly WindowsBase

# FULL # BEGIN FULL: Don't include this in the installer script
if(!(Get-Command Invoke-WebRequest -ErrorAction SilentlyContinue)){
  Import-Module $PSScriptRoot\InvokeWeb
}
# NOTE: these types are needed elsewhere (Packaging Module)
#       the types aren't needed for the installer
#       but they are part of the "packaging light" module, so here they are.
# We need to make up a URL for the metadata psd1 relationship type
$Script:ModuleMetadataType      = "http://schemas.poshcode.org/package/module-metadata"
$Script:ModuleHelpInfoType      = "http://schemas.poshcode.org/package/help-info"
$Script:PackageThumbnailType    = "http://schemas.openxmlformats.org/package/2006/relationships/metadata/thumbnail"
# I'm not sure there's any benefit to extra types:
# CorePropertiesType is the .psmdcp
$Script:CorePropertiesType      = "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties"
$Script:ModuleRootType          = "http://schemas.poshcode.org/package/module-root"
$Script:ModuleContentType       = "http://schemas.poshcode.org/package/module-file"
# FULL # END FULL

# This is what nuget uses for .nuspec, we use it for .moduleinfo ;)
$Script:ManifestType            = "http://schemas.microsoft.com/packaging/2010/07/manifest"
# Our Extensions
$Script:ModuleInfoExtension     = ".psdxml"
$Script:ModuleManifestExtension = ".psd1"
$Script:ModulePackageExtension  = ".psmx"

function Install-ModulePackage {
  #.Synopsis
  #   Install a module package to the module 
  [CmdletBinding(SupportsShouldProcess=$true, ConfirmImpact="Medium", DefaultParameterSetName="UserPath")]
  param(
    # The package file to be installed
    [Parameter(ValueFromPipelineByPropertyName=$true, Mandatory=$true, Position=0)]
    [Alias("PSPath","PackagePath","ModuleInfoUri")]
    $Package,

    # The PSModulePath to install to
    [Parameter(ParameterSetName="InstallPath", Mandatory=$true, Position=1)]
    [Alias("PSModulePath")]
    $InstallPath,

    # If set, the module is installed to the Common module path (as specified in Packaging.ini)
    [Parameter(ParameterSetName="CommonPath", Mandatory=$true)]
    [Switch]$Common,

    # If set, the module is installed to the User module path (as specified in Packaging.ini)
    [Parameter(ParameterSetName="UserPath")]
    [Switch]$User,

    # If set, overwrite existing modules without prompting
    [Switch]$Force,

    # If set, the module is imported immediately after install
    [Switch]$Import,

    # If set, output information about the files as well as the module 
    [Switch]$Passthru,

    #  Specifies the client certificate that is used for a secure web request. Enter a variable that contains a certificate or a command or expression that gets the certificate.
    #  To find a certificate, use Get-PfxCertificate or use the Get-ChildItem cmdlet in the Certificate (Cert:) drive. If the certificate is not valid or does not have sufficient authority, the command fails.
    [System.Security.Cryptography.X509Certificates.X509Certificate[]]
    $ClientCertificate,

    #  Pass the default credentials
    [switch]$UseDefaultCredentials,

    #  Specifies a user account that has permission to send the request. The default is the current user.
    #  Type a user name, such as "User01" or "Domain01\User01", or enter a PSCredential object, such as one generated by the Get-Credential cmdlet.
    [System.Management.Automation.PSCredential]
    [System.Management.Automation.Credential()]
    [Alias("")]$Credential = [System.Management.Automation.PSCredential]::Empty,

    # Specifies that Authorization: Basic should always be sent. Requires $Credential to be set, and should only be used with https
    [ValidateScript({if(!($Credential -or $WebSession)){ throw "ForceBasicAuth requires the Credential parameter be set"} else { $true }})]
    [switch]$ForceBasicAuth,

    # Uses a proxy server for the request, rather than connecting directly to the Internet resource. Enter the URI of a network proxy server.
    # Note: if you have a default proxy configured in your internet settings, there is no need to set it here.
    [Uri]$Proxy,

    #  Pass the default credentials to the Proxy
    [switch]$ProxyUseDefaultCredentials,

    #  Pass specific credentials to the Proxy
    [System.Management.Automation.PSCredential]
    [System.Management.Automation.Credential()]
    $ProxyCredential= [System.Management.Automation.PSCredential]::Empty     
  )
  dynamicparam {
    $paramDictionary = new-object System.Management.Automation.RuntimeDefinedParameterDictionary
    if(Get-Command Get-ConfigData -ErrorAction SilentlyContinue) {
      foreach( $name in (Get-ConfigData).Keys ){
        if("CommonPath","UserPath" -notcontains $name) {
          $param = new-object System.Management.Automation.RuntimeDefinedParameter( $Name, [Switch], (New-Object Parameter -Property @{ParameterSetName=$Name;Mandatory=$true}))
          $paramdictionary.Add($Name, $param)
        }
      } 
    }
    return $paramdictionary
  }  
  begin {
    if($PSCmdlet.ParameterSetName -ne "InstallPath") {
      $Config = Get-ConfigData
      switch($PSCmdlet.ParameterSetName){
        "UserPath"   { $InstallPath = $Config.UserPath }
        "CommonPath" { $InstallPath = $Config.CommonPath }
        # "SystemPath" { $InstallPath = $Config.SystemPath }
      }
      $PsBoundParameters.Remove(($PSCmdlet.ParameterSetName + "Path"))
      $PsBoundParameters.Add("InstallPath", $InstallPath)
    }
    if(!(Test-Path variable:RejectAllOverwriteOnInstall)){
      $RejectAllOverwriteOnInstall = $false;
      $ConfirmAllOverwriteOnInstall = $false;
    }
  }
  process {
    if("$Package" -match "^https?://" ) {
      # Make sure the InstallPath has a file name:
      # TODO: This is currently very simplistic, based on the URL alone which
      #       requires the URL to have NO query string, and end in a file name
      #       it would be better to have Invoke-Web figure out the file name...
      if(Test-Path $InstallPath -PathType Container) {
        $OutFile = Join-Path $InstallPath (Split-Path $Package -Leaf)
      } else {
        $OutFile = $InstallPath
      }
      
      Write-Verbose "Fetch '$Package' to '$OutFile'"

      $WebParam = @{} + $PsBoundParameters
      $WebParam.Add("Uri",$Package)
      $WebParam.Add("OutFile",$OutFile)
      $null = "Package", "InstallPath", "Common", "User", "Force", "Import", "Passthru" | % { $WebParam.Remove($_) }

      $Package = Invoke-WebRequest @WebParam -ErrorVariable FourOhFour
      if($FourOhFour){
        $PSCmdlet.ThrowTerminatingError( $FourOhFour[0] )
      }
      # If we used the built-in Invoke-WebRequest, we don't have the file yet...
      if($Package -isnot [System.IO.FileInfo]) { $Package = Get-ChildItem $OutFile }
    }
    # Now lets open it as a package
    $PackagePath = Resolve-Path $Package -ErrorAction Stop

    # TODO: Make this more bullet-proof (it's just testing extensions right now)
    # If we just got back an xml file, figure out the real package Uri and recurse
    if($ModuleInfoExtension -eq [IO.Path]::GetExtension($PackagePath)) {
      $Mi = Get-ModuleInfo $PackagePath
      Remove-Item $PackagePath
      if($Mi.PackageUri) {
        Write-Verbose "Found PackageUri '$($Mi.PackageUri)' in Module Info file '$PackagePath' -- Installing by Uri"
        $PsBoundParameters["Package"] = $Mi.PackageUri
        Install-ModulePackage @PsBoundParameters
        return
      }
    }

    $InstallPath = "$InstallPath".TrimEnd("\")

    # Warn them if they're installing in an irregular location
    [string[]]$ModulePaths = $Env:PSModulePath -split ";" | Resolve-Path -ErrorAction SilentlyContinue | Convert-Path -ErrorAction SilentlyContinue
    if(!($ModulePaths -match ([Regex]::Escape($InstallPath) + ".*"))) {
      if((Get-PSCallStack | Where-Object{ $_.Command -eq "Install-ModulePackage" }).Count -le 1) {
        Write-Warning "Install path '$InstallPath' is not in yout PSModulePath!"
      }
    }

    # At this point $PackagePath is a local file, but it might be a .zip or .nupkg:
    $Manifest = Get-ModuleManifestXml $PackagePath
    if(!$Manifest) {
      Write-Warning "'$Package' is not a valid PoshCode Package, using Install-ModuleArchive"
      Install-ModuleArchive $PackagePath $InstallPath
      return
    }

    # We need to verify the RequiredModules are available, or install them.
    if($Manifest."ModuleManifest.RequiredModules") {
      $FailedModules = @()
      foreach($RequiredModule in $Manifest."ModuleManifest.RequiredModules".ModuleId) {
        # If the module is available ... 
        $VPR = "SilentlyContinue"
        $VPR, $VerbosePreference = $VerbosePreference, $VPR
        if($Module = Get-Module -Name $RequiredModule.Name -ListAvailable) {
          $VPR, $VerbosePreference = $VerbosePreference, $VPR
          if($Module = $Module | Where-Object { $_.Version -ge $RequiredModule.Version }) {
            if($Import) {
              Import-Module -Name $RequiredModule.Name -MinimumVersion
              continue
            }
          } else {
            Write-Warning "The package $PackagePath requires $($RequiredModule.Version) of the $($RequiredModule.Name) module. Yours is version $($Module.Version). Trying upgrade:"
          }
        } else {
            Write-Warning "The package $PackagePath requires the $($RequiredModule.Name) module. Trying install:"
        }
        # Check for a local copy, maybe we get lucky:
        $Folder = Split-Path $PackagePath
        # Check with and without the version number in the file name:
        if(($RequiredFile = Get-Item (Join-Path $Folder "$($RequiredModule.Name)*$ModulePackageExtension") | 
                              Sort-Object { [IO.Path]::GetFileNameWithoutExtension($_) } | 
                              Select-Object -First 1) -and
           (Get-ModuleManifestXml $RequiredFile).Version -ge $RequiredModule.Version)
        {
          Write-Warning "Installing required module $($RequiredModule.Name) from $RequiredFile"
          Install-ModulePackage $RequiredFile $InstallPath
          continue
        } 
        # If they have a ModuleInfoUri, try that:
        if($RequiredModule.ModuleInfoUri) {
          Write-Warning "Installing required module $($RequiredModule.Name) from $($RequiredModule.ModuleInfoUri)"
          Install-ModulePackage $RequiredModule.ModuleInfoUri $InstallPath
          continue
        } 

        Write-Warning "The module package does not have a ModuleInfoUri for the required module $($RequiredModule.Name), and there's not a local copy."
        $FailedModules += $RequiredModule
        continue
      }
      if($FailedModules) {
        Write-Error "Unable to resolve required modules."
        Write-Output $FailedModules
        return # TODO: Should we install anyway? Prompt?
      }
    }

    try {
      $Package = [System.IO.Packaging.Package]::Open( $PackagePath, "Open", "Read" )
      Write-Host ($Package.PackageProperties|Select-Object Title,Version,@{n="Guid";e={$_.Identifier}},Creator,Description, @{n="Package";e={$PackagePath}}|Out-String)

      $ModuleName = $Package.PackageProperties.Title
      if($InstallPath -match ([Regex]::Escape($ModuleName)+'$')) {
        $InstallPath = Split-Path $InstallPath
      }

      if($PSCmdlet.ShouldProcess("Extracting the module '$ModuleName' to '$InstallPath\$ModuleName'", "Extract '$ModuleName' to '$InstallPath\$ModuleName'?", "Installing $($ModuleName)" )) {
        if($Force -Or !(Test-Path "$InstallPath\$ModuleName" -ErrorAction SilentlyContinue) -Or $PSCmdlet.ShouldContinue("The module '$InstallPath\$ModuleName' already exists, do you want to replace it?", "Installing $ModuleName", [ref]$ConfirmAllOverwriteOnInstall, [ref]$RejectAllOverwriteOnInstall)) {
          $success = $false
          if(Test-Path "$InstallPath\$ModuleName") {
            Remove-Item "$InstallPath\$ModuleName" -Recurse -Force -ErrorAction Stop
          }
          $null = New-Item -Type Directory -Path "$InstallPath\$ModuleName" -Force -ErrorVariable FailMkDir
          
          ## Handle the error if they asked for -Common and don't have permissions
          if($FailMkDir -and @($FailMkDir)[0].CategoryInfo.Category -eq "PermissionDenied") {
            throw "You do not have permission to install a module to '$InstallPath\$ModuleName'. You may need to be elevated."
          }

          foreach($part in $Package.GetParts() | where Uri -match ("^/" + $ModuleName)) {
            $fileSuccess = $false
            # Copy the data to the file system
            try {
              if(!(Test-Path ($Folder = Split-Path ($File = Join-Path $InstallPath $Part.Uri)) -EA 0) ){
                $null = New-Item -Type Directory -Path $Folder -Force
              }
              Write-Verbose "Unpacking $File"
              $writer = [IO.File]::Open( $File, "Create", "Write" )
              $reader = $part.GetStream()

              Copy-Stream $reader $writer -Activity "Writing $file"
              $fileSuccess = $true
            } catch [Exception] {
              $PSCmdlet.WriteError( (New-Object System.Management.Automation.ErrorRecord $_.Exception, "Unexpected Exception", "InvalidResult", $_) )
            } finally {
              if($writer) {
                $writer.Close()
                $writer.Dispose()
              }
              if($reader) {
                $reader.Close()
                $reader.Dispose()
              }
            }
            if(!$fileSuccess) { throw "Couldn't unpack to $File."}
            if($Passthru) { Get-Item $file }
          }
        } else { # !Force
          $Import = $false # Don't _EVER_ import if they refuse the install
        }
        $success = $true
      } # ShouldProcess
    } catch [Exception] {
      $PSCmdlet.WriteError( (New-Object System.Management.Automation.ErrorRecord $_.Exception, "Unexpected Exception", "InvalidResult", $_) )
    } finally {
      $Package.Close()
      $Package.Dispose()
    }
    if(!$success) { throw "Couldn't unpack $ModuleName." }
    if($Import) {
      Import-Module $ModuleName -Passthru:$Passthru
    } else {
      Get-Module $ModuleName
    }
  }
}

function Get-ModuleInfo {
  #.Synopsis
  #  Get information about a module from the ModuleInfo manifest or the psd1 metadata file.
  [CmdletBinding()]
  param(
    # The name of the module (or path)
    [Parameter(ValueFromPipeline=$true, ValueFromPipelineByPropertyName=$true, Mandatory=$true)]
    [Alias("ModuleInfoPath","ModuleManifestPath","PSPath","Path","Name")]
    $Module
  )
  process {
    [string]$ModuleManifestPath = ""
    [string]$ModuleInfoPath = ""

    # If the parameter isn't already a ModuleInfo object, then let's make it so:
    if($Module -is "string" -or $Module -is [System.IO.FileInfo] -or $Module -is [System.Management.Automation.PathInfo]) {
      if(Split-Path $Module) {
        $ModulePath = Convert-Path $Module -ErrorAction SilentlyContinue -ErrorVariable noPath
        if($noPath) { $ModulePath = $Module }
      } else {
        $ModulePath = $Module
      }
      $Module = $null
      $Extension = [IO.Path]::GetExtension($ModulePath)
      # It should be either a String or a FileInfo (if it's a string, it might begmo)
      Write-Verbose "Switch on Extension: $Extension  ($ModulePath)"
      switch($Extension) {
        $ModuleInfoExtension {
          Write-Verbose "Finding Module by ModuleInfoPath"
          $ModuleInfoPath = $ModulePath
          $ModuleManifestPath = [IO.Path]::ChangeExtension($ModuleInfoPath, $ModuleManifestExtension)
        }
        $ModuleManifestExtension {
          Write-Verbose "Finding Module by ModuleManifestPath"
          # We have a path to a .psd1
          $ModuleManifestPath = $ModulePath
          $ModuleInfoPath = [IO.Path]::ChangeExtension($ModuleManifestPath, $ModuleInfoExtension)
        }
        $ModulePackageExtension {
          Write-Verbose "Finding Module by ModuleManifestPath"
          Get-ModuleManifestXml $ModulePath |
          Add-Member NoteProperty PackagePath $ModulePath -Passthru |
          Add-Member NoteProperty PSPath ("{0}::{1}" -f $ModulePath.Provider, $ModulePath.ProviderPath) -Passthru
          return 
        }
        default {
          Write-Verbose "Finding Module by Module Name: $ModulePath"
          # Hopefully, they've just specified a module name:

          $VPR = "SilentlyContinue"
          $VPR, $VerbosePreference = $VerbosePreference, $VPR
          $Module = Get-Module $ModulePath -ListAvailable
          $VPR, $VerbosePreference = $VerbosePreference, $VPR
          # In this case, there's probably lots of them, so we need to recurse:
          $Module | Get-ModuleInfo
          return
        }
      }

      if(!$Module -and (Test-Path $ModulePath)) {
        Write-Verbose "Searching for Module by Path"
        # They got crazy and passed us a path instead of a name ...
        $ModuleBase = $ModulePath
        if(Test-Path $ModulePath -PathType Leaf) {
          $ModuleBase = Split-Path $ModulePath
        }
        # Hopefully, it's at least in the PSModulePath (or already loaded)
        $VPR = "SilentlyContinue"
        $VPR, $VerbosePreference = $VerbosePreference, $VPR
        $Module = Get-Module (Split-Path $ModuleBase -Leaf) -ListAvailable | Where-Object { $_.ModuleBase -eq $ModuleBase }
        $VPR, $VerbosePreference = $VerbosePreference, $VPR
        # But otherwise, we can always try importing it:
        if(!$Module) {
          Write-Verbose "Finding Module by Import-Module (least optimal method)"
          $Module = Import-Module $ModulePath -Passthru -ErrorAction SilentlyContinue
          if($Module) {
            Remove-Module $Module
          }
        }
      }
    }
    if($Module) {
      $ModuleInfoPath = Join-Path $Module.ModuleBase "$($Module.Name)$ModuleInfoExtension"
      $ModuleManifestPath = Join-Path $Module.ModuleBase "$($Module.Name)$ModuleManifestExtension"
    }

    if(Test-Path $ModuleInfoPath) {
      Write-Verbose "Loading ModuleManifest"
      $ModuleInfo = ([xml](gc $ModuleInfoPath)).ModuleManifest | 
                      Add-Member NoteProperty ModuleInfoPath $ModuleInfoPath -Passthru | 
                      Add-Member NoteProperty ModuleManifestPath $ModuleManifestPath -Passthru | 
                      Add-Member NoteProperty Path $ModuleManifestPath -Passthru
      Write-Output $ModuleInfo
    }
    elseif($Module) 
    {
      Write-Verbose "Write out PSModuleInfo"
      Write-Output ($Module | 
                      Add-Member NoteProperty ModuleInfoPath $ModuleInfoPath -Passthru | 
                      Add-Member NoteProperty ModuleManifestPath $ModuleManifestPath -Passthru)
    } 
    else 
    {
      throw "Unable to get ModuleInfo"
    }
  }
}

##### Private functions ######
function Get-ModuleManifestXml {
  # .Synopsis
  # Try reading the module manifest from the package
  param( 
    $ModulePath 
  )
  end {
    try {
      $Package = [System.IO.Packaging.Package]::Open( (Convert-Path $ModulePath), [IO.FileMode]::Open, [System.IO.FileAccess]::Read )

      $Manifest = @($Package.GetRelationshipsByType( $ManifestType ))[0]
      if(!$Manifest -or !$Manifest.TargetUri) {
        Write-Warning "This file is not a valid PoshCode Package, it has not specified the manifest"
        return
      }

      $Part = $Package.GetPart( $Manifest.TargetUri )
      if(!$Part) {
        Write-Warning "This file is not a valid PoshCode Package, it has no manifest at $($Manifest.TargetUri)"
        return
      }

      try {
        $stream = $part.GetStream()
        $reader = New-Object System.IO.StreamReader $stream
        # This gets the ModuleInfo
        ([xml]$reader.ReadToEnd()).ModuleManifest
      } catch [Exception] {
        $PSCmdlet.WriteError( (New-Object System.Management.Automation.ErrorRecord $_.Exception, "Unexpected Exception", "InvalidResult", $_) )
      } finally {
        if($reader) {
          $reader.Close()
          $reader.Dispose()
        }
        if($stream) {
          $stream.Close()
          $stream.Dispose()
        }
      }

    } catch [Exception] {
      $PSCmdlet.WriteError( (New-Object System.Management.Automation.ErrorRecord $_.Exception, "Unexpected Exception", "InvalidResult", $_) )
    } finally {
      $Package.Close()
      $Package.Dispose()
    }
  }
}

function Copy-Stream {
  #.Synopsis
  #   Copies data from one stream to another
  param(
    # The source stream to read from
    [IO.Stream]
    $reader,

    # The destination stream to write to
    [IO.Stream]
    $writer,

    [string]$Activity = "File Packing",

    [Int]
    $Length = 0
  )
  end {
    $bufferSize = 0x1000 
    [byte[]]$buffer = new-object byte[] $bufferSize
    [int]$sofar = [int]$count = 0
    while(($count = $reader.Read($buffer, 0, $bufferSize)) -gt 0)
    {
      $writer.Write($buffer, 0, $count);

      $sofar += $count
      if($Length -gt 0) {
         Write-Progress -Activity $Activity  -Status "Copied $sofar of $Length" -ParentId 0 -Id 1 -PercentComplete (($sofar/$Length)*100)
      } else {
         Write-Progress -Activity $Activity  -Status "Copied $sofar bytes..." -ParentId 0 -Id 1
      }
    }
    Write-Progress -Activity "File Packing" -ParentId 0 -Id 1 -Complete
  }
}

function Select-ModulePath {
  #.Synopsis
  #   Interactively choose (and validate) a folder from the Env:PSModulePath
  [CmdletBinding(SupportsShouldProcess=$true, ConfirmImpact="High")]
  param(
    # The folder to install to. This folder should be one of the ones in the PSModulePath, NOT a subfolder.
    $InstallPath
  )
  end {
    $ChoicesWithHelp = @()
    [Char]$Letter = "D"
    $default = -1
    $index = -1
    $common = -1
    switch -Wildcard ($Env:PSModulePath -split ";" | ? {$_}) {
      "${PSHome}*" {
        ##### We do not support installing to the System location. #####
        #$index++
        #$ChoicesWithHelp += New-Object System.Management.Automation.Host.ChoiceDescription "S&ystem", $_
        continue
      }
      "$(Split-Path $PROFILE)*" {
        $index++
        $ChoicesWithHelp += New-Object System.Management.Automation.Host.ChoiceDescription "&Profile", $_
        $default = $index
        continue
      }
      "$(Join-Path ([Environment]::GetFolderPath("ProgramFiles")) Microsoft)\Windows\PowerShell\Modules*" {
        $index++
        $ChoicesWithHelp += New-Object System.Management.Automation.Host.ChoiceDescription (if($common -lt 0){"&Common"}elseif($common -lt 1){"C&ommon"}else{"Co&mmon"}), $_
        $common++
        if($Default -lt 0){$Default = $index}
        continue
      }
      "$(Join-Path ([Environment]::GetFolderPath("CommonProgramFiles")) Modules)*" {
        $index++
        $ChoicesWithHelp += New-Object System.Management.Automation.Host.ChoiceDescription (if($common -lt 0){"&Common"}elseif($common -lt 1){"C&ommon"}else{"Co&mmon"}), $_
        $common++
        if($Default -lt 0){$Default = $index}
        continue
      }
      "$(Join-Path ([Environment]::GetFolderPath("CommonDocuments")) Modules)*" {
        $index++
        $ChoicesWithHelp += New-Object System.Management.Automation.Host.ChoiceDescription (if($common -lt 0){"&Common"}elseif($common -lt 1){"C&ommon"}else{"Co&mmon"}), $_
        $common++
        if($Default -lt 0){$Default = $index}
        continue
      }
      "$([Environment]::GetFolderPath("MyDocuments"))*" { 
        $index++
        $ChoicesWithHelp += New-Object System.Management.Automation.Host.ChoiceDescription "&MyDocuments", $_
        if($Default -lt 0){$Default = $index}
        continue
      }
      default {
        $index++
        $Key = $_ -replace [regex]::Escape($Env:USERPROFILE),'~' -replace "((?:[^\\]*\\){2}).+((?:[^\\]*\\){2})",'$1...$2'
        $ChoicesWithHelp += New-Object System.Management.Automation.Host.ChoiceDescription "&$Letter $Key", $_
        $Letter = 1 + $Letter
        continue
      }
    }
    # Let's try and make sure they have one of our two known "Common" locations:
    if($common -lt 1) {
      $index++
      $ChoicesWithHelp += New-Object System.Management.Automation.Host.ChoiceDescription "&Common", "$([Environment]::GetFolderPath("CommonDocuments"))\Modules"
    }
    # And we always offer the "Other" location:
    $index++
    $ChoicesWithHelp += New-Object System.Management.Automation.Host.ChoiceDescription "&Other", "Type in your own path!"

    while(!$InstallPath -or !(Test-Path $InstallPath)) {
      if($InstallPath -and !(Test-Path $InstallPath)){
        if($PSCmdlet.ShouldProcess(
          "Verifying module install path '$InstallPath'", 
          "Create folder '$InstallPath'?", 
          "Creating Module Install Path" )) {

          $null = New-Item -Type Directory -Path $InstallPath -Force -ErrorVariable FailMkDir
        
          ## Handle the error if they asked for -Common and don't have permissions
          if($FailMkDir -and @($FailMkDir)[0].CategoryInfo.Category -eq "PermissionDenied") {
            Write-Warning "You do not have permission to install a module to '$InstallPath\$ModuleName'. You may need to be elevated. (Press Ctrl+C to cancel)"
          } 
        }
      }

      if(!$InstallPath -or !(Test-Path $InstallPath)){
        $Answer = $Host.UI.PromptForChoice(
          "Please choose an install path.",
          "Choose a Module Folder (use ? to see the full paths)",
          ([System.Management.Automation.Host.ChoiceDescription[]]$ChoicesWithHelp),
          $Default)

        if($Answer -ge $index) {
          $InstallPath = Read-Host ("You should pick a path that's already in your PSModulePath. " + 
                                    "To choose again, press Enter.`n" +
                                    "Otherwise, type the path for a 'Modules' folder you want to create")
        } else {
          $InstallPath = $ChoicesWithHelp[$Answer].HelpMessage
        }
      }
    }

    return $InstallPath
  }
}

function Test-ExecutionPolicy {
  #.Synopsis
  #   Validate the ExecutionPolicy
  param()

  $Policy = Get-ExecutionPolicy
  if(([Microsoft.PowerShell.ExecutionPolicy[]]"Restricted","Default") -contains $Policy) {
    $Warning = "Your execution policy is $Policy, so you will not be able import script modules."
  } elseif(([Microsoft.PowerShell.ExecutionPolicy[]]"AllSigned") -eq $Policy) {
    $Warning = "Your execution policy is $Policy, if modules are not signed, you won't be able to import them."
  }
  if($Warning) {
    Write-Warning ("$Warning`n" +
        "You may want to change your execution policy to RemoteSigned, Unrestricted or even Bypass.`n" +
        "`n" +
        "        PS> Set-ExecutionPolicy RemoteSigned`n" +
        "`n" +
        "For more information, read about execution policies by executing:`n" +
        "        `n" +
        "        PS> Get-Help about_execution_policies`n")
  } elseif(([Microsoft.PowerShell.ExecutionPolicy]"Unrestricted") -eq $Policy) {
    Write-Host "Your execution policy is $Policy and should be fine. Note that modules flagged as internet may still cause warnings."
  } elseif(([Microsoft.PowerShell.ExecutionPolicy]"RemoteSigned") -contains $Policy) {
    Write-Host "Your execution policy is $Policy and should be fine. Note that modules flagged as internet will not load if they're not signed."
  } 
}

# FULL # BEGIN FULL: This cmdlet is only needed in the full version of the module
function Update-Module {
  #.Synopsis
  #   Checks if you have the latest version of each module
  #.Description
  #   Test the ModuleInfoUri indicate if there's an upgrade available
  [CmdletBinding(SupportsShouldProcess=$true, ConfirmImpact="Medium")]
  param(
    # The name of the module to package
    [Parameter(ValueFromPipeline=$true)]
    [ValidateNotNullOrEmpty()] 
    $Module = "*",

    # Only test to see if there are updates available (don't do the actual updates)
    # This is similar to -WhatIf, except it outputs objects you can examine...
    [Switch]$TestOnly,

    # Force an attempt to update even modules which don't have a ModuleInfoUri
    [Switch]$Force,

    #  Specifies the client certificate that is used for a secure web request. Enter a variable that contains a certificate or a command or expression that gets the certificate.
    #  To find a certificate, use Get-PfxCertificate or use the Get-ChildItem cmdlet in the Certificate (Cert:) drive. If the certificate is not valid or does not have sufficient authority, the command fails.
    [System.Security.Cryptography.X509Certificates.X509Certificate[]]
    $ClientCertificate,

    #  Pass the default credentials
    [switch]$UseDefaultCredentials,

    #  Specifies a user account that has permission to send the request. The default is the current user.
    #  Type a user name, such as "User01" or "Domain01\User01", or enter a PSCredential object, such as one generated by the Get-Credential cmdlet.
    [System.Management.Automation.PSCredential]
    [System.Management.Automation.Credential()]
    [Alias("")]$Credential = [System.Management.Automation.PSCredential]::Empty,

    # Specifies that Authorization: Basic should always be sent. Requires $Credential to be set, and should only be used with https
    [ValidateScript({if(!($Credential -or $WebSession)){ throw "ForceBasicAuth requires the Credential parameter be set"} else { $true }})]
    [switch]$ForceBasicAuth,

    # Uses a proxy server for the request, rather than connecting directly to the Internet resource. Enter the URI of a network proxy server.
    # Note: if you have a default proxy configured in your internet settings, there is no need to set it here.
    [Uri]$Proxy,

    #  Pass the default credentials to the Proxy
    [switch]$ProxyUseDefaultCredentials,

    #  Pass specific credentials to the Proxy
    [System.Management.Automation.PSCredential]
    [System.Management.Automation.Credential()]
    $ProxyCredential= [System.Management.Automation.PSCredential]::Empty  

  )
  process {
    $ModuleInfo = Get-ModuleInfo $Module | Add-Member NoteProperty Update -Value "Unknown" -Passthru

    if(!$Force) {
      # Unless they -Force, filter out modules without manifests
      $ModuleInfo = $ModuleInfo | Where-Object {$_.ModuleInfoUri}
    }

    Write-Verbose "Testing for new versions of $(@($ModuleInfo).Count) modules."
    foreach($M in $ModuleInfo){
      Write-Progress "Updating module $($M.Name)" "Checking for new version (current: $($M.Version))" -id 0
      if(!$M.ModuleInfoUri) {
        # TODO: once the search domain is up, we need to do a search here.
        Write-Warning "Unable to check for update to $($M.Name) because there is no ModuleInfoUri"
        continue
      }

      ## Download the ModuleInfoUri and see what version we got...
      $WebParam = @{Uri = $M.ModuleInfoUri}
      # TODO: This is currently very simplistic, based on the URL alone which
      #       requires the URL to have NO query string, and end in a file name
      #       it would be better to have Invoke-Web figure out the file name...
      $WebParam.OutFile = Join-Path ([IO.path]::GetTempPath()) (Split-Path $M.ModuleInfoUri -Leaf)
      try { # A 404 is a terminating error, but I want to handle it my way.
        $VPR = "SilentlyContinue"
        $VPR, $VerbosePreference = $VerbosePreference, $VPR
        $ModuleInfoFile = Invoke-WebRequest @WebParam -ErrorVariable WebException -ErrorAction SilentlyContinue
      } catch [System.Net.WebException]{
        if(!$WebException) { $WebException = $_.Exception }
      } finally {
        $VPR, $VerbosePreference = $VerbosePreference, $VPR
      }
      if($WebException){
        Write-Warning "Can't fetch ModuleInfo from $($M.ModuleInfoUri) for $($M.Name): $(@($WebException)[0].Message)"
        continue # Check the rest of the modules...
      }

      # If we used the built-in Invoke-WebRequest, we don't have the file yet...
      if($ModuleInfoFile -isnot [System.IO.FileInfo]) { $ModuleInfoFile = Get-ChildItem $WebParam.OutFile }
    
      # Now lets find out what the latest version is:
      $ModuleInfoFile = Resolve-Path $ModuleInfoFile -ErrorAction Stop
      $Mi = Get-ModuleInfo $ModuleInfoFile

      $M.Update = [Version]$Mi.Version
      Write-Verbose "Latest version of $($M.Name) is $($mi.Version)"

      $InstallPath = ""
      # They're going to want to install it where it already is:
      $Paths = $Env:PSModulePath -split "\s*\\?;\s*" | %{ $_.TrimEnd("/\ ") } | sort-object length -desc
      foreach($Path in $Paths) {
        if($M.ModuleManifestPath.StartsWith($Path)) {
          $InstallPath = $Path
          break
        }
      }

      # If we need to update ...
      if(!$TestOnly -and $M.Update -gt $M.Version) {

        if($PSCmdlet.ShouldProcess("Upgrading the module '$($M.Name)' from version $($M.Version) to $($M.Update)", "Update '$($M.Name)' from version $($M.Version) to $($M.Update)?", "Updating $($M.Name)" )) {
          if(!$InstallPath) {
            $InstallPath = Split-Path (Split-Path $M.ModuleManifestPath)
          }

          $InstallParam = @{InstallPath = $InstallPath} + $PsBoundParameters
          $null = "Module", "TestOnly" | % { $InstallParam.Remove($_) }

          # If the InfoUri and the PackageUri are the same, then we already downloaded it
          if($M.ModuleInfoUri -eq $Mi.PackageUri) {
            $InstallParam.Add("Package", $ModuleInfoFile)
          } else {
            # Get rid of the temporarily downloaded package info
            Remove-Item $ModuleInfoFile
            $InstallParam.Add("Package", $Mi.PackageUri)
          }

          Install-ModulePackage @InstallParam
        }
      } elseif($TestOnly) {
        $M | Select-Object Name, Author, Version, Update, PackageUri, ModuleInfoUri, ModuleInfoPath, @{name="PSModulePath";expression={$InstallPath}}
      }
    }
  }
}

function Install-ModuleArchive {
  #.Synopsis
  #   Install a module package to the module 
  [CmdletBinding(SupportsShouldProcess=$true, ConfirmImpact="High", DefaultParameterSetName="UserPath")]
  param(
    # The package file to be installed
    [Parameter(ValueFromPipeline=$true, ValueFromPipelineByPropertyName=$true, Mandatory=$true, Position=0)]
    [Alias("PSPath","PackagePath")]
    $ZipFile,

    # The PSModulePath to install to
    [Parameter(ParameterSetName="InstallPath", Mandatory=$true, Position=1)]
    [Alias("PSModulePath")]
    $InstallPath,

    [Switch]$Force
  )

  $ZipFile = (Resolve-Path $ZipFile -ErrorAction Stop).Path

  $ModuleName = [IO.Path]::GetFileNameWithoutExtension($ZipFile)
  if($InstallPath -notmatch ([Regex]::Escape($ModuleName)+'$')) {
    $InstallPath = Join-Path $InstallPath $ModuleName
  }

  Write-Verbose "Expand ZipFile '$ZipFile' to '$InstallPath'"

  if(Get-Command Expand-ZipFile) {
    $InstallPath = Expand-ZipFile $ZipFile $InstallPath
  } else {
    # This is the backup plan for the backup plan, lets just please ... unzip the thing!
    # Note: one problem with this method is that it has GUI!
    $shellApplication = new-object -com shell.application
    $zipPackage = $shellApplication.NameSpace($ZipFile)
    if($zipPackage.Items().Count  -eq 1) {
      $InstallPathParent = Split-Path $InstallPath
      $InstallPath = Join-Path $InstallPathParent (@($zipPackage.Items())[0].Path -replace ([Regex]::Escape($ZipFile)))
    }

    if(Test-Path $InstallPath) {
      if($Force -or $PSCmdlet.ShouldContinue("The InstallPath exists and is not empty. Are you sure you want to overwrite '$InstallPath'?", "Deleting contents of '$InstallPath'")) {
        Remove-Item $InstallPath -Recurse -ErrorAction Stop
      } else {
        throw "InstallPath '$InstallPath' Exists."
      }
    }
    [string]$InstallPathParent = New-Item $InstallPath -Type Directory -Force
    $shellApplication.NameSpace($InstallPathParent).CopyHere($zipPackage.Items())
  }

  Write-Verbose "Extracted '$ZipFile' to '$InstallPath'"

  # If there's only one child, that's probably a module folder:
  $Children = Get-ChildItem $InstallPath
  if(@($Children).Count -eq 1 -and $Children.PSIsContainer) {
    $ChildName = $Children.Name
    if($Children.Name -eq (Split-Path $InstallPath -Leaf)) {
      Write-Verbose "Moving items in '$($Children.FullName)' up a level to '$(Join-Path (Split-Path $InstallPath) $ChildName)'"
      Move-Item "$($Children.FullName)\*" $InstallPath
      Remove-Item $Children.FullName
    } else {
      $InstallPath = Join-Path (Split-Path $InstallPath) $ChildName
      if(Test-Path $InstallPath) {
        if($Force -or $PSCmdlet.ShouldContinue("The InstallPath exists and is not empty. Are you sure you want to overwrite '$InstallPath'?", "Deleting contents of '$InstallPath'")) {
          Remove-Item $InstallPath -Recurse -ErrorAction Stop
        } else {
          throw "InstallPath '$InstallPath' Exists."
        }
      }
    }
  }

  $ModulePath = $InstallPath
  $Children = Get-ChildItem $InstallPath
  # if there were .psd1 files in the root, one of them should be the module name!
  if($metadata = ($Children | Select-Object -Expand FullName) -like "*.psd1") {
    # if one of them matches the module name, everything is ok, and we're done!
    if($metadata | Where-Object { $_.BaseName -eq $ModuleName }) {
      Get-Item $ModulePath
    } else {
      # if none of them match, we probably just need to rename the folder:
      if(@($metadata).Count -eq 1) {
        $ModulePath = Join-Path (Split-Path $InstallPath) ([IO.Path]::GetFileNameWithoutExtension($metadata))
      } else {
        # TODO: otherwise, pick one somehow...
        $FileString = $(foreach($BaseName in $InstallPath | % { $_.BaseName }) {
          Get-ChildItem (Join-Path $InstallPath "${BaseName}.*")
        }) | Format-Table | Out-String -Stream

        Write-Host $FileString
        $Name = Read-Host "Please enter the real name of this module:"
        $Module = Get-ChildItem (Join-Path $InstallPath "${Name}.*") -Filter "*.psd1"
        if(!$Module) {
          $Module = Get-ChildItem (Join-Path $InstallPath "${Name}.*") -Filter "*.psm1"
        }
        if($Module) {
          $Name = $Module.BaseName
        }
        $ModulePath = Join-Path (Split-Path $InstallPath) ([IO.Path]::GetFileNameWithoutExtension($Name))
      }
      Write-Verbose "Desired Module Path: $ModulePath"
      if("$InstallPath" -ne "$ModulePath") {
        if(Test-Path $ModulePath) {
          if($Force -or $PSCmdlet.ShouldContinue("The InstallPath exists, are you sure you want to overwrite '$ModulePath'?", "Deleting contents of '$ModulePath'")) {
            Remove-Item $ModulePath -Recurse -ErrorAction Stop
          } else {
            throw "InstallPath '$InstallPath' Exists."
          }
        }
        Rename-Item $InstallPath $ModulePath
      }
      Get-Item $ModulePath
    }
  # Otherwise, if there are no files, the folder(s) must be modules, let's move them and give up.
  } elseif(!($Children | Where-Object { !$_.PSIsContainer })) {
    Write-Verbose "Module $InstallPath contains multiple modules:"
    $TemporaryFolder = $InstallPath
    $InstallPath = Split-Path $InstallPath
    foreach($child in $Children) {
      $ChildModulePath = Join-Path $InstallPath $child.Name
      Write-Verbose "Extracting $ChildModulePath"
      if(Test-Path $ChildModulePath) {
        if($Force -or $PSCmdlet.ShouldContinue("The Module $($Child.Name) exists, are you sure you want to overwrite '$ChildModulePath'?", "Deleting contents of '$ChildModulePath'")) {
          Remove-Item $ChildModulePath -Recurse -ErrorAction Stop
          Move-Item $Child.FullName -Destination $ChildModulePath -Passthru
        } else {
          Write-Warning "Leaving $($Child.Name) in '$($Child.PSParentPath)'"
        }
      } else {
        Move-Item $Child.FullName -Destination $ChildModulePath -Passthru
      }
    }
    # If we moved everything out, then clean up after ourselves.
    if(!(Get-ChildItem $TemporaryFolder)) {
      Remove-Item $TemporaryFolder
    }
  }
}

try {
  Add-Type -As System.IO.Compression.FileSystem -ErrorAction SilentlyContinue

  function Expand-ZipFile {
    #.Synopsis
    #  Expand a zip file, ensuring it's contents go to a single folder ...
    [CmdletBinding()]
    param(
      # The path of the zip file that needs to be extracted
      [Parameter(ValueFromPipelineByPropertyName=$true, Position=0, Mandatory=$true)]
      [Alias("PSPath")]
      $FilePath,

      # The path where we want the output folder to end up
      [Parameter(Position=1)]
      $OutputPath = $Pwd,

      # Make sure the resulting folder is always named the same as the archive
      [Switch]$Force
    )
    process {
      $ZipFile = Get-Item $FilePath
      $Archive = [System.IO.Compression.ZipFile]::Open( $ZipFile, "Read" )

      # Figure out where we'd prefer to end up
      if(Test-Path $OutputPath) {
        if($Force -or $PSCmdlet.ShouldContinue("The OutputPath exists and is not empty. Are you sure you want to overwrite '$OutputPath'?", "Deleting contents of '$OutputPath'")) {
          Remove-Item $OutputPath -Recurse -Force -ErrorAction Stop
        } else {
          throw "OutputPath '$OutputPath' Exists."
        }
        $Destination = $OutputPath
      } else {
        # Otherwise, since they passed a folder, they must want us to use it
        $Destination = $OutputPath
      }

      # The root folder of the first entry ...
      $ArchiveRoot = ($Archive.Entries[0].FullName -Split "/|\\")[0]

      Write-Verbose "Desired Destination: $Destination"
      Write-Verbose "Archive Root: $ArchiveRoot"

      # If any of the files are not in the same root folder ...
      if($Archive.Entries.FullName | Where-Object { @($_ -Split "/|\\")[0] -ne $ArchiveRoot }) {
        if(Test-Path $Destination) {
          if($Force -or $PSCmdlet.ShouldContinue("The Destination exists and is not empty. Are you sure you want to overwrite '$Destination'?", "Deleting contents of '$Destination'")) {
            Remove-Item $Destination -Recurse -Force -ErrorAction Stop
          } else {
            throw "Destination '$Destination' Exists."
          }
        }

        # extract it into a new folder:
        New-Item $Destination -Type Directory -Force
        [System.IO.Compression.ZipFileExtensions]::ExtractToDirectory( $Archive, $Destination )
      } else {
        $OutputPath = (Split-Path $Destination)
        Write-Verbose "Output Path: $OutputPath (+ $ArchiveRoot)"

        $ArchivePath = Join-Path $OutputPath $ArchiveRoot

        if(Test-Path $ArchivePath) {
          if($Force -or $PSCmdlet.ShouldContinue("The Destination exists and is not empty. Are you sure you want to overwrite '$ArchivePath'?", "Deleting contents of '$ArchivePath'")) {
            Remove-Item $ArchivePath -Recurse -Force -ErrorAction Stop
          } else {
            throw "ArchivePath '$ArchivePath' Exists."
          }
        }

        # otherwise, extract it up a level and lets see what we get
        [System.IO.Compression.ZipFileExtensions]::ExtractToDirectory( $Archive, $OutputPath )

        # If there was only a single file in the archive, then we'll just output that file...
        if($Archive.Entries.Count -eq 1) {
          # Except, if they asked for an OutputPath with an extension on it, we'll rename the file to that ... 
          if([System.IO.Path]::GetExtension($Destination)) {
            Move-Item (Join-Path $OutputPath $Archive.Entries[0].FullName) $Destination -Passthru
          } else {
            Get-Item (Join-Path $OutputPath $Archive.Entries[0].FullName)
          }
        } elseif($Force) {
          # Otherwise let's make sure that we move it to where we expect it to go, in case the zip's been renamed
          if((Join-Path $OutputPath $ArchiveRoot) -ne $Destination) {
            Move-Item $ArchivePath $Destination -Passthru
          } else {
            Get-Item $ArchivePath
          }
        } else {
          Get-Item $ArchivePath
        }
      }

      $Archive.Dispose()
    }
  }
} catch { }
# FULL # END FULL

Export-ModuleMember -Function Install-ModulePackage, Install-ModuleArchive, Update-Module, Get-ModuleInfo, Copy-Stream -Alias * -Variable *
